import { Smitter } from 'smitter';
import { Params, MultiValueParams, Event as LambdaEvent, Context as LambdaContext, Response as LambdaResponse } from 'lambda-types';
import { Mode } from './';
export declare type PrestaConfig = {
    /**
     * @description the current working directory (default `process.cwd()`)
     */
    cwd: string;
    /**
     * @description file globs to include in build process
     */
    files: string[];
    /**
     * @description path to static asset directory (default `./public`)
     */
    assets: string;
    /**
     * @description array of Presta plugins
     */
    plugins: Plugin[];
    /**
     * @description user requested port (default `4000`)
     */
    port: number;
    /**
     * @description whether or not to run the local dev HTTP server (default `false`)
     */
    serve: boolean;
    /**
     * @description option to output debug logs during dev (default `false`)
     */
    debug?: boolean;
    /**
     * @description the raw args passed in via the Presta CLI
     */
    rawCliArgs: PrestaCliArgs;
    /**
     * @description inclues all dependencies in the final bundle instead of
     * externalizing them
     */
    __unsafe_bundle_everything: boolean;
};
export declare type PrestaCliArgs = {
    /**
     * @description variadic CLI args (Presta files)
     */
    _?: string[];
    /**
     * @description user provided config filepath
     */
    config?: string;
    /**
     * Re-declared because CLI arg comes in as a string
     *
     * @description whether or not to run the local dev HTTP server (default `false`)
     */
    serve?: string;
    /**
     * Re-declared because CLI arg comes in as a string
     *
     * @description option to output debug logs during dev (default `false`)
     */
    debug?: string;
} & Partial<Omit<PrestaConfig, 'files' | 'plugins' | 'rawCliArgs' | 'serve'>>;
export declare type Headers = Params;
export declare type MultiValueHeaders = MultiValueParams;
export declare type QueryStringParameters = Params;
export declare type MultiValueQueryStringParameters = MultiValueParams;
export declare type PathParameters = Params;
export declare type Event = Omit<LambdaEvent, 'queryStringParameters' | 'multiValueQueryStringParameters' | 'pathParameters'> & {
    queryStringParameters: Params;
    multiValueQueryStringParameters: MultiValueParams;
    pathParameters: Params;
};
export declare type Context = LambdaContext & {
    [key: string]: unknown;
};
export declare type Response = Omit<LambdaResponse, 'statusCode'> & {
    statusCode?: number;
};
export declare type Handler = (event: Event, context: Context) => Promise<Response | string> | Response | string;
export declare type AWSLambda = (event: Event, context: Context) => Promise<LambdaResponse>;
export declare type PrestaFile = {
    route?: string;
    getStaticPaths?: () => Promise<string[]>;
    handler: Handler;
};
export declare type PrestaFunctionFile = PrestaFile & {
    route: string;
};
export declare type PrestaStaticFile = PrestaFile & {
    getStaticPaths: () => Promise<string[]>;
};
export declare type Manifest = {
    /**
     * @description The built pages and files from the Presta process. These are
     * output to the same directory as the `config.assets` static assets.
     */
    statics: {
        [filepath: string]: string[];
    };
    /**
     * @description The built AWS Lambda-flavored serverless functions
     */
    functions: {
        [filepath: string]: {
            route: string;
            src: string;
            dest: string;
        };
    };
};
export declare type InternalEvents = {
    devServerRestarted: undefined;
    requestRestartDevServer: undefined;
    devFileAdded: undefined;
    devFileRemoved: undefined;
    devFileChanged: undefined;
};
export declare type ExternalEvents = {
    buildComplete: undefined;
};
export declare type LoggerMetadata = {
    duration?: string;
};
export declare type Logger = {
    debug(message: string, metadata?: LoggerMetadata): void;
    info(message: string, metadata?: LoggerMetadata): void;
    warn(message: string, metadata?: LoggerMetadata): void;
    error(error: Error | string, metadata?: LoggerMetadata): void;
};
export declare type PluginInterface = {
    /**
     * @description The package name of the Presta plugin e.g.
     * `@presta/adapter-netlify`
     */
    name: string;
    /**
     * @description Called when dev server restarts, like after an edit is made
     * to the config file. Clean up any and all listeners and side-effects within
     * this method.
     */
    cleanup?(): void;
};
export declare type PluginContext = {
    mode: Mode;
    cwd: string;
    events: {
        on: Smitter<ExternalEvents>['on'];
    };
    logger: Logger;
    getManifest(): Manifest;
    getOutputDir(): string;
    getStaticOutputDir(): string;
    getFunctionsOutputDir(): string;
    restartDevServer(): void;
};
export declare type Plugin = (context: PluginContext) => PluginInterface;
export declare type LogLevel = 'debug' | 'info' | 'warn' | 'error';
export declare const defaultJSConfigFilepath = "presta.config.js";
export declare const defaultTSConfigFilepath = "presta.config.ts";
export declare const rootOutputDir = "./.presta";
export declare const functionsOutputDir = "./.presta/functions";
export declare const staticOutputDir = "./.presta/static";
export declare function createLiveReloadScript({ port }: {
    port: number;
}): string;
export declare function slugify(filename: string, cwd: string): string;
/**
 * Accepts the Manifest's functions object and sorts it according to route
 * priority, returning the full object
 */
export declare function sortManifestFunctions(functions: Manifest['functions']): {};
export declare function findAndParseConfigFile(userProvidedConfigFilepath?: string): Partial<PrestaConfig>;
export declare function mergeConfig(configFile: Partial<PrestaConfig>, cliArgs?: PrestaCliArgs): PrestaConfig;
export declare function pathnameToFile(pathname: string, ext?: string): string;
export declare function getMimeType(response: LambdaResponse): string;
/**
 * Loads the _source_ file, not the built file
 */
export declare function loadSourceFunctionFileFromManifest(url: string, manifest: Manifest): {
    filepath: string;
    exports: PrestaFunctionFile;
};
export declare class Presta {
    cwd: string;
    /**
     * Full config, with CLI arguments merged in
     */
    config: PrestaConfig;
    /**
     * Whether in production or development
     */
    mode: Mode;
    /**
     * The port presta will serve files from in dev mode
     */
    port: number;
    /**
     * @description option to output debug logs during dev (default `false`)
     */
    debug: boolean;
    /**
     * Output directory for static assets and generated files
     */
    staticOutputDir: string;
    /**
     * Output directory for serverless functions. This is probably separate from
     * where adapters output files.
     */
    functionsOutputDir: string;
    /**
     * Hidden .presta dir for internal files
     */
    prestaOutputDir: string;
    /**
     * Filepath to output build manifest to, within `config.output` directory
     */
    manifestFilepath: string;
    /**
     * Full build manifest. Should be kept up to date as files are added/removed/built.
     */
    manifest: Manifest;
    /**
     * All watched files, computed from `config.files` or CLI args.
     */
    files: string[];
    /**
     * Event emitters for both internal events and external events consumed by
     * users and plugins
     */
    events: {
        internal: Smitter<InternalEvents>;
        external: Smitter<ExternalEvents>;
    };
    /**
     * <script> tag added to all HTML responses, depends on `this.config.port`
     */
    liveReloadScript: string;
    plugins: PluginInterface[];
    logger: Logger;
    constructor(config: Partial<PrestaConfig>);
    /**
     * Build all files and copy static assets to `config.output`.
     */
    build(): Promise<void>;
    dev(): Promise<{
        /**
         * Ends the watch process. Mostly useful for internal testing.
         */
        cleanup(): Promise<void>;
    }>;
    serve(): void;
    /**
     * Restarts the entire dev process and rebuilds *all* files. Usually used by
     * plugins after a critical configuration change. *Use with caution.*
     */
    restartDevServer(): void;
    /**
     * Loads a module from filepath and generates static files and functions
     */
    buildFile(filepath: string): Promise<void>;
    /**
     * Wrapper around `this.buildFile`
     */
    buildFiles(filepaths: string[]): Promise<void>;
    /**
     * Called during start/restart. References `this.config` to compute some
     * instance properties that are used throughout the instance methods (and so
     * must be called after this.config is set or updated). Also parses the
     * user-input file globs to discover targeted files and assign to
     * this.files`.
     */
    private _init;
    private _serve;
    private _log;
    /**
     * The main dev process
     */
    private _initDev;
    /**
     * Assigns `this.port` and must be called when starting dev or serve modes
     */
    private _getPort;
    /**
     * Commits `this.manifest` to a file on system.
     */
    private _commitManifestToFile;
    private _httpServerHandler;
    private _httpTryServeFile;
    private _httpTryServeLambda;
}
